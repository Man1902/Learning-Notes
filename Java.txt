----- Reactive Programming in JAVA ----- 
- What is Reactive Programming ?
  * It is new programming paradigm.
  * Asynchronous and non-blocking
  * Event/Message driven
  * Functional code style




- JVM : Specification(Abstract machine)
  * loads,verifies and executes code.Responsible for converting Byte code to the machine specific code.
  * Provides core java functions like memory management, garbage collection, security etc.
  * It is customizable and we can use java options to customize it.
  * It is called virtual because it provides an interface that does not depend on the underlying operating system and machine hardware.
  * JVM is the heart of java programming language and provides platform independence.
- JRE : Implementation of JVM.- 
  * Physically exist.It Contains JVM,libraries classes and other files.
  * It provides a platform to execute java programs.
- JDK : JRE + development tools(Compiler,Debugger etc).
  * It provides all the tools, executables and binaries required to compile, debug and execute a Java Program.
- JVM,JRE and JDK are platform dependent (Config of each OS differs) but java is platform independent.
- JDK is for development purpose whereas JRE is for running the java programs.JDK and JRE both contains JVM so that we can run our java program.
- Compile time : A.java -> Comipler -> A.class (byte code)
- Run time : byte code -> Class loader -> byte code verifier -> interpreter -> Runtime -> hardware.
- Compiler converts source code to bytecode and then the JVM executes the bytecode generated by the compiler.This bytecode can run on any platform.
  Each operating system has a different JVM, but the output produced by all the OS is the same after the execution of bytecode. That is why we call java a platform-independent language.
- Just-in-time Compiler (JIT) : JIT is part of the JVM that optimizes the process of converting byte code to machine-specific language.
  * It compiles similar byte codes at the same time and reduces the overall time taken for the compilation of byte code to machine-specific language.
  
- Class Loder : responsible for loading class files into memory from file system,network or any other source. 
  1) Bootstrap : responsile for loading standard JDK class files from rt.jar. parent of all class loaders.
  2) Extension  : It delegates class loading request to its parent (Bootstrap) and if it is unsuccessful, loads class form jre/lib/ext directory or any other 
     directory pointed by java.ext.dirs system property. 
  3) System / Application : responsile for loading application specific classes from CLASSPATH environment variable.Child of Extension classloader.
- Bootstrap classloader is implemented in C while all other classloders are implemented using java.lang.ClassLoader.
-* ClassLoader works in three principles : 
  1) delegation : Application -> Extension -> Bootstrap (if class is not found from parent than only child classloader will load class by itself)
  2) visibility : Child ClassLoader can see class loaded by Parent ClassLoader but reverse is not true.
  3) uniqueness : class loaded by Parent should not be loaded by Child ClassLoader again.(Though it is possible to violate Delegation and Uniqueness principles 
     but we should avoid it as it is not beneficial)
- We can create our own classloader by extending ClassLoader class and overriding loadClass(String name) method.
-* "ClassNotFoundException" is thrown when JVM  tries to load a particular class and the specified class cannot be found in the classpath.It is a checked 
   exception and thus, must be declared using throws or handled using try catch block.
-* While "NoClassDefFoundError"(Error derived from LinkageError) occurs when requested class was present at compile time but not available at runtime
  (Sometimes due to an exception during class initialization e.g. exception from static block causes NoClassDefFoundError)
- Object : Entity having state(data) and behaviour (methods acting on data).Class : Collection of objects (logical entity).
-* Java is pass by value.In method call,java copies and pass references as value,not object.Hence,object state can be modfiy but swap will fail.
- local variables don’t take default values(before initialization can't be used).But,gloabal variables takes default values. 
- After loading static members, SIB are executed(before main).SIBs are not stored in the heap memory.They just come to stack,execute their tasks and leaves the memory. 
- You can define multiple SIB.They will be executed sequentially.
-* All static components are stored inside single "class level object" (of type java.lang.Class).(common for all objects).
- Non-static components are stored inside the object memory where each object will have their own copy.
-* In constructor,1st statement must be either super() or this().After executing it,it will invoke IIB and after that remaining statements are executed.
- OOP principles : 1) Inheritance 2) Polymorphism 3) Abstraction 4) Encapsulation 5) Association 6) Aggregation 7) Composition
1) Inheritance : 
   * IS-A relationship ( Sub Class IS-A Super class)
   * used to reuse already present tried and tested code and leveraging Polymorphism by creating a type hierarchy.
   * allows a class to inherit non-private behavior (methods) and data (fields) from other class.
   * Constructors,SIB and IIB of super class will not be inherited by subclass.But they are executed while creating an object to sub class.(Order : SIB,IIB,Constructor)
   * To avoid the ambiguity due to Diamond problem, multiple inheritance through class is not supported in java.
   * Java supports single, multi-level and multiple inheritances (through interface only)
   * It's better to use Inheritance for type declaration but for code reuse composition is a better option because it's more flexible. 
   * final classes can not be extended (inherited)
- Access modifiers : are used to control the visibility of a field, method, class and constructor.
  * Protected member/method is accesible to classes in same package,as well as all sub classes in other package (through inheritance).
  * If outer class is protected,it should be accesible to the current package as well as sub package.There is no concept of sub package in java.Hence,Outer Class
    can not be protected.
  * Sub class can not be created from class having private constructor only.(as super call as first line is not possible)
  * Sub class can be created from class having protected constructor.But sub class object can't be created outside package.
- Type casting 1) Primitive (Auto widening and explicit narrowing) 2) Derived (Auto up-cating and explicit down-casting) 
  * Auto-Up Casting : Super class reference sub class object , Explicit down Casting : Sub-class reference Super class object.
2) Polymorphism : 
   * Enity (Method/Constructor) having same name wih multiple behaviour.
   * Compile time Polymorphism : Static/Early binding.(Constructor and method overloading)
   * Run time Polymorphism : Dynamic/Late binding.(Method overriding).Type of object is determined at runtime only.
   * Method overloading : Class with same method name and different signature.(Doesn't bother about return type and static/final)(int and Integer is also diffrent)
   * Method overriding : Inherited super(parent) class method is modiefied in sub(child) class.
   * Covariant return type : Return type of the overrided method must be compatible with super class method.(for primitive same and for derived same or its sub class).
   * Visibility of overrided method can't be reduce and method signature can not be change.
   * Static method can not be override because it's resolved at compile time (invoke according to the type of reference) while In order for overriding to work,
     a method should be virtual and resolved at runtime (instance method is invoked according to the type of object) because objects are only available at runtime.
   * Static method of CC cannot hide instance method of PC and instance method of CC cannot override a static method of PC.(But static method can be overloded)
   * Method hiding : when sub class has same static method as parent class's static metohd, it's method hiding.
   * You can not override Base class variables in sub class.(Because variables are resolved at compile time according to refrence type). e.g 
     A -> int i=1; , B -> int i=2; , A a = new B(); , a.i will give 1
   * Variable hiding : When Parent and child class both have same variable name (even if their types are diffrent),the child class variable hides the parent class
     variable (will not override)
   * Variable shadowing : When local variable has the same name as one of the instance variable,Then local variable shadows the instance variable inside method/block.
   * Through inheritance we can reuse already existing code and through method overriding (runtime polymorphism) we can modify that reused code.
3) Abstraction : 
   * It is used to define common behavior without implementation.(Abstract class : 0 to 100% , Interface : 100%)
   * Abstraction in Java is implemented using abstract class and interface.
   * "programming for interface than implementation design principle" is based on abstraction.
   * Abstraction hides details at the design level.
   * Class having behavior declaration only will inform us "What should be done" while implementing class will tell us "How it should be done"
   * Object can not be createcd for abstract class/interface(Reason : Abstract class/interface is not a complete class.If we are allowed to have instance of it,
     than it will throw compilatation error for abstract method as it doesn't have implementation). But, abstract class can have constructor. (Diff)
   * We can run an abstract class if it has main() method whereas we can’t run an interface. (Diff)
   * Abstract method must be overrided (so can't be private or static or final). Only class and method can be abstract.
   * SIB and IIB are not allowed in interfaces.
- super keyword refers to instance of super/parent class while this keyword refers current instance(object) of class. 
- final keyword : restricts the further modification of variable,method and class.Class/Method can be either final or abstract(not both).
  * For Final reference variable, we can change state of object being refered.
- Marker Interface : interface having no fields and methods(empty).used to notify(give some kind of instruction) JVM. e.g Cloneable,Serializable
4) Encapsulation : 
   * Encapsulation means hiding details of implementation (data hiding) from outside world so that when things change no body gets affected.
   * e.g private methods.clients  don't care about it, You can change/remove it easily.
   * Encapsulation is implemented using private, package-private and protected access modifier.
   * "encapsulate whatever changes design principle" is based upon Encapsulation.
   * Encapsulation hides details at the implementation level.
   * It is a process of wrapping data(variables) and code acting on the data (methods) together into a single unit.
   * It is used to hide the internal details of a class e.g. HashMap encapsulate how to store elements and how to calculate hash values.
   * It provides control over the data.It allows you to control who can access what.
   * It gives flexibility to make the variables of the class as read-only or write-only.It improves the re-usability.
   * Encapsulated Code is more flexible and easy to change with new requirements.It makes unit testing easy.
   * It also helps to write immutable class in Java which is a good choice in multi-threading environment.
   * Factory pattern , Singleton pattern in Java makes good use of Encapsulation.
5) Association : 
   * defines the relationship between objects. one-to-one, one-to-many , many-to-many.
   * However, in association, both objects are independent of each other.
6) Aggregation : 
   * It is a special type of association. 
   * Both objects have their own life cycle but there is ownership. 
   * we have “HAS-A” relationship between objects and ownership.
7) Composition : 
   * It is a special case of aggregation.It is a more restrictive form of aggregation.
   * When the contained object in “HAS-A” relationship can’t exist on its own, then it’s a case of composition. e.g
     House has-a Room. Here the room can’t exist without the house
   * Composition is said to be better than inheritance. 
	 * Composition is more flexible because you can change the implementation at runtime.(We can get runtime binding in composition where inheritance binds the classes at compile time)
     * we can control the visibility of other object to client classes and reuse only what we need.
	 * In inheritance, Any change in the superclass might affect subclass even though we might not be using the superclass methods.
	 * Inheritance exposes all the superclass methods and variables to the client and if we have no control in designing superclass, it can lead to security holes. 
	   Composition allows us to provide restricted access to the methods and hence more secure.
- Wrapper class provides the mechanism to convert primitive into object (Boxing) and object into primitive (Unboxing).
  * Since Java 1.5 , It is happening automatically
  * All the wrapper classes in java are immutable and final.
  * parse() : object to primitive , valueOf() : primitive to object.
- When primitive data type passed as method argument : 
  1) compiler first checks method having same data type. 
  2) It tries to perform 'auto-boxing" of "same type" only 
  3)It tries to perform "auto-widening" conversion 
  4) It checks for the method which takes "super class type" (up casting) 
  5) gives compile time error.
- String :   
  * Why String class is immutable / final (Once created can't modify it) in java ?
	  * String Pool Requirement : If string is not immutable, changing the string with one reference will lead to the wrong value for the other references.
	  * Hashcode can be cached : Being immutable guarantees that hashcode will always the same.This makes it a great candidate for the key in a Map.
	  * Security : String is widely used as parameter for many java classes.e.g database username, password,url
	  * Can be used in multithreading : Strings are implicitly thread-safe due to immutability.
	  * Strings are used in java classloader and immutability provides security that correct class is getting loaded by Classloader
  * StringBuffer and StringBuilder objects are "mutable". 
  * Object of StingBuffer and StingBuilder are stored in "heap memory" only.
  * Only String and StringBuffer objects are thread safe (synchronized).
  * Whenever you create a string object using "string literal", that object is stored in the "string constant pool"(cache of string object in Perm gen space.which
    is now moved to heap memory from 1.7 onwards) and whenever you create a string object using "new keyword", such object is stored in the "heap memory".
  * "==" operator checks the equality based on their "physical existence in the memory"(physical address) while equals() method checks the equality based on
    their content.("==" operator compares references not values while "equals()" method compares values of string for equality) 
  * Interning is the process of creating a string object in String Constant Pool which will be exact copy of string object in heap memory. 
  * What is Immutable class ?
    * Immutable class means that once an object is created, we cannot change its state. e.g all wrapper class (Integer, Boolean, Byte, Short) and String class
  * How to Create Custom Immutable Class ? 
	1) final class.		// so that it can't be inherited
	2) private final data members.		// so can't be access directly and value can't be modiefied after object creation)   
	3) parametrized constructor to initialize data members.	// Perform a deep copy/cloning for reference field So that data members can’t be modified with object reference.
    4) getters only		// In the getter method,Perform a deep copy/ cloning for object reference field to return a copy rather than actual object reference.(e.g for Date,other class object) 
	5) No setters 		// To not have the option to change the value of the instance variable.
- Singleton class : 
  * class which has only one instance in whole application.e.g Runtime class
  * It can maintain state. But, change in state from one reference can impact other references also (as there is only one object)
  * It can't be inherited (due to private constructor)
  * Custom Singleton Class :  
    * private constructor, private static variable of Singleton class type , public static getInstance method which returns object of Singleton class type.
	* Variants : Eagar, Static block, Lazy, Thread Safe, With Reflection, Cloning and Serialization handling
- static class is a Java class, which only contains static methods. e.g java.lang.Math
- If your Singleton class is not maintaining any state, and just providing global access to methods, than consider using static class, as static methods are much
  faster than Singleton, because of static binding during compile time.
- Array :  is a collection of similar type of elements that have contiguous memory location.
  * Data type of Array can be primitive,object or user defiend.
  * Array copy ways : 1) Direct asign source array reference to dest array ref. 2) Using for loop 3) Using Array.copyOf() 4) Using Objerct class clone() method
    5) Using System.arraycopy() method.
  * Array can hold the references to any type of objects. Array can contain only references to the objects, not the objects itself.(default is null)
  * Declaration and instantiation of an array strictly must be of same type.Only auto-upcasting is allowed.(Object a[] = new String[])
  * When an array is passed to a method, reference of an array object is passed not the copy of the object.
  * Size of an array can not be changed once you define it.(drawback)
- for-each loop in java is the enhanced version of for loop (Java 1.5 Onwards)
- Generics (introduced in Java 1.5) : 
  * used to check the "type compatibility" at the "compile time" and hence avoid the chances of occuring "ClassCastException" at "run time".
  * Generics works with "derived type" only (primitive type not allowed).
  * Only "generic classes" can implement "generic interfaces". 
  * Normal class can implement generic interface only if type of parameter of generic interface is "wrapper class".
  * Generic class can extend a non-generic class also.
  * Like class or interface, Method and constructor can be generic. Method syntax : <type-Parameters> return_type method_name(parameter list) {}
	* Generic methods can be static or non-static.
	* Generic class as well as non-generic class can have generic methods.
  * Using bounded types, you can make the objects of generic class to have data of "specific derived types". e.g <T extends SuperClass>
    * The types which are used to declare wildcard arguments (?) must be generic types.
	  1) Unknown Type : GenericType<?>		2) Upper Bound  : GenericType<? extends SuperClass>		3) Lower Bound  : GenericType<? super SubClass> 
  * Non-generic class can extend generic class by removing the type parameters. i.e as a raw type. But, it gives a warning.
  * Generic methods of super class can be overrided in the sub class like normal methods.
  * When you compile your java code, compiler removes all generic information mentioned in your code. 
  * Compiler replaces all type parameters with their bounded type.The type parameters which don't have bounds will be replaced with "Object" class.
  * You can't create an instance to the type parameters. This is because, the type parameters does not exist at run time.
  * You can't create an array of generic type.(e.g  T[] t = new T[5]).Because,Array carries type information at runtime while for generic type, compiler removes
    type information at compilation) 
  * You can not create generic exceptions i.e A generic class can not extend Throwable or any of it's sub classes.
  * Diff : arrays are covariant.you can assign subclass type array to its superclass array reference e.g Object a[] = new Integer[10]; // will work
    While generics are invariant.you cannot assign subclass type generic to its super class generic reference because in generics any two distinct types are 
    neither a subtype nor a supertype. e.g 
	1) List<Object> list = new ArrayList<Integer>(); // won't compile
	2) List<? extends Object> list = new ArrayList<Integer>(); // will work with bounded type

- Collection(I) : 
  * root interface in the collection hierarchy.represents a group of objects (elements).JDK does not provide any direct implementations of this interface.
  * equals() and hashCode() method's general contract : c1.equals(c2) implies that c1.hashCode() == c2.hashCode()
  1)List(I) : represents an ordered or sequential collection of objects.
	 * You have the control over where to insert an element and from where to remove an element in the list.(Due to index based IMPL). 
	 * ArrayList,Vector and LinkedList implements List.
     * ListIterator allows you to traverse the list in both the direction, modify (insert, replace, remove) the list during iteration.
  2)Queue(I) : is a "data structure" where elements are added from one end (tail) and elements are removed from another end (head).(FIFO except priority queue)
     * can't have null elements . can have duplicate elements. can't have random access.
  3)Deque(I) (Double Ended Queue) supports insertion and removal of elements from both the ends.(Introduced in Java 1.6)
     * Deque can be used as a both: Queue (FIFO) as well as Stack (LIFO).
	 * can have null elements. can have duplicate elements. can't have random access.
     * Deque as Queue : 1) add() -> addLast(), offer() -> offerLast() 2) remove() -> removeFirst(), poll() -> pollFirst() 
	   3) element() ->  getFirst(),peek() -> peekFirst()  
     * Deque as stack : 1) push() -> addFirst() 2) pop() -> removeFirst() 3) peek() -> peekFirst()
  4)Set(I) : is a linear collection of objects with no duplicates.
     * Can have only one null element. Random access not allowed.
     * Order of elements in a set is implementation dependent.
	 * HashSet elements are ordered on "hash code" of elements. 
	 * TreeSet elements are ordered according to supplied Comparator (If not supplied, elements will be placed in ascending order).
	 * LinkedHashSet maintains insertion order. 
  5)SortedSet(I) : is a Set in which elements are placed according to supplied comparator(default accesnding order if not provided).
     * It can not have null elements as inserted element must be of comparable type)
  6)NavigableSet(I) is a SortedSet with navigation facilities.
     * It provides many methods through which you can easily find closest matching of any given element.
  7)ArrayList(C) : can be defined as "re-sizable" array. 
     * can have null elements . can have duplicate elements. can have random access.
     * Maitains insertion order. not synchronized.
	 * ArrayList internally uses an array to store its elements(Object[] elementData). It provides methods to manipulate the size of this array.
	 * Whenever the "size" of the ArrayList exceeds it's "capacity"(internal array size : Default is 10),the capacity is increased by "half" of the "current capacity".
	 * ArrayList extends AbstractList class and implements List, RandomAccess, Cloneable, Serializable inteface.
  8)Vector(C) : Legacy class. synchronized(thread safe). 
     * Default initial capacity:10. capacity will be doubled automatically when size exceed
	 * can traverse using Enumeration
  9)LinkedList(C) : in java is implementation of "doubly Linked List".can be used both as a List and Queue.
    * LinkedList extends AbstractSequentialList class and implements List, Deque, Cloneable, Serializable inteface.
					ArrayList									 						LinkedList
	  * Insertion/Removal is slower of O(n) dueto element shifting		* Insertion/Removal is faster of O(1) due to no element shifting 
	  * Retrival is faster of O(1) due to index based data structure    * Retrival is slower of O(n) due to searching from head/tail till element
	  * Requires less memory as it holds actual data only 				* Requires more memory as each node contains data as well as refrence to prev and next node
 10)PriorityQueue(C) :  is special type of Queue(not FIFO).
     * Elements are placed according to supplied Comparator. 
	 * Default initial capacity : 11. can't have null elements. can have duplicate elements. not synchronized . unbounded
 11)ArrayDeque(C) : is resizable array.
     * Implementation of Deque(I).Default initial capacity : 16.It will increase at a power of 2 when size exceeds.
     * ArrayDeque is faster than Stack when used as Stack and faster than LinkedList when used as Queue.
	 * ArrayDeque gives performance of O(1) for Insertion/Removal/Retrival operations.
 12)Map(I) : is a collection of key-value pairs. 
     * can't have duplicate key but can have duplicate values.
	 * Each key-value pairs are stored as Map.Entry<K,V> objects. Entry is and inner interface of Map interface.
	 * Load factor is a measure which decides when to increase the capacity of Map.Default load factor is 0.75f (n/m  where n : keys , m : slots)
 13)HashMap(C) : 
	 * Default initial capacity of HashMap is : 16 (number of bucket/slot).It is doubled each time when reaches the threshold.
	 * In HashMap each key-value pair is stored as an object of static inner Entry<K,V> class.which contains key(final),value,next node and hash fields.
	 * These Entry objects are stored in an internal array called table[](Entry<K,V>[] table).It's initial size is 16.
	 * Put operation : 1) find hashCode() of key 2) Calculate bucket index (Hashcode & bucketSize-1) 3) if bucket empty add node at that index 
	   4) if node exist and key matched replace old node wih new one 5) if node exist and key don't match add node at last in existing linked list node
	 * In HasMap searching in linkedlist is O(n) in worst case  when all entries are saved in same bucket.To overcome this isssue, from Java 8, linked list is 
       replaced (after certain limit TREEIFY_THRESHOLD = 8) by tree to search in O(logN).
 14)HashSet(C) :  internally uses HashMap.
	 * Elements are stored as a key of HashMap and values are constant called PRESENT.
 15)LinkedHashSet(C) : is an ordered version of HashSet.
     * internally maintains one "doubly liked list" (responsible for maintaining the insertion order of elements)
	 * LinkedHashSet uses LinkedHashMap to store its elements.
	 * Each key-value pairs are instance of it's static inner class "Entry<K,V>".(Which extends HashMap.Entry class).This class contains two additional fields 
	   "before" and "after" which makes LinkedHashSet to function as doubly liked list.
 16)TreeSet(C) : doesn't allow null element.
     * It gives performance of order O(log(n)) for insertion,removal and retrival operations.
  * HashSet and LinkedHashSet uses equals() and hashcode() methods for element comparison while TreeSet uses compare() or compareTo() method.
  * HashMap doesn't maintain any order of elements.LinkedHashMap maintains insertion order while TreeMap places elements according to the supplied Comparator. 
  * HashMap,LinkedHashMap and TreeMap are not synchronized.
  * Use Collections.synchronizedCollection(c) or Collections.synchronizedList/Set/Map(obj) to make ArrayList/HashSet/HashMap synchronized.
 17)HashTable(C) : extends Dictionary class(legacy class) and implements Map,cloneable and Serializable interface.
     * It is internally synchronized. 
	 * HashTable does not allow even a single null key and null value.It returns  Iterator as well as Enmeration.
 18)Iterator :  return by HashMap/ArrayList/HashSet is fail-fast. 
    * It will throw ConcurrentModificationException if modified during iteration other than iterator's remove method.
    * Fail-safe iterator does not throw any exception if collection is modified during iteration.Because, it operates on the clone of collection.
    * All collection types maintain an internal array of objects (Object[]) to stores the elements.Fail-fast iterators directly fetch the elements from this 
	  array.They always consider that this inernal array must not be changed during iteration. 
 18)Enmeration(I) : legacy, fail-safe, can be used with legacy classes only (Vector, HashTable and Stack)
 19)Comparable(I) : provides single sorting sequence while. affects the original class.
 20)Comparator(I) : provides multiple sorting sequence.doesn't affects the original class.
 21)BlocingQueue : support operations that will check that Queue is not empty while retrieving and removing and will wailt till space is available while adding.
    IMPL : ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue etc. Usage : to implement producer consumer problem
  * Thread safe and fail-safe iterator implementation concurrent classes : CopyOnWriteArrayList, ConcurrentHashMap, CopyOnWriteArraySet.
  * HashTable uses synchronized methods to achieve thread safety (quite slow due to contention).Perfomance wise Synchronized Map is also not very diffrent than 
    Hashtable.On the other hand, ConcurrentHashMap allows 16 threads to allow Read and write from Map without any external synchronization.It is also very scalable
    because of stripped locking technique.It never locks whole Map, instead it divides the Map into segments and locking is done on those.
  * Collections.unmodifiableCollection(Collection c) (unmodifiableList/unmodifiableSet/unmodifiableMap) is used to create read-only collection before passing it 
    as method argument,this will make sure that any operation to change the collection will throw UnsupportedOperationException.
 22)WeakHashMap : if object is specified as key which doesn’t contain any references,it is eligible for garbage collection even though it is associated with WeakHashMap.
    * Here,Garbage Collector dominates over WeakHashMap.
	* But this is not applicable in HashMap.Means for HashMap, HashMap dominates over Garbage Collector.
 23)IdentityHashMap : is used when the user requires the objects to be compared via reference.
    * It uses equality operator “==” instead of the equals method for comparing keys and values.
	* It doesn’t require keys to be immutable.
 24)EnumMap : is specialized implementation of Map which contains key of Enum type.
 
- Exception Handling : 
  * try block : used to enclose the code that might throw an exception.
  * catch block : used to handle the exceptions thrown by try block.
  * finally block : will be always execute Whether exception is thrown or not and thrown exception is caught or not.
  * From Java 1.7, Multiple exceptions thrown by the try block can be handled by a single catch block  using pipe (|) operator.
  * Order of catch blocks should be from "most specific" to "most general".(Sub classe Exception first and super class later).
  * If finally block does not return a value then both try and catch blocks must return a value.
  * finally block will be always executed even though try and catch blocks are returning the control.
  1) Checked exception : 
     * checked at "compile time".Thus, have to handle it using throws or try/catch block to avoid compilation error.
     * All Sub class of Exception class except RuntimeException class)e.g SQLException,IOException,InterruptedException
  2) UnChecked exception : 
     * checked at run time.All sub class of RuntimeException and Error class. e.g ArithmeticException, NumberFormatException, NullPointerException, 
	   ArrayIndexOutOfBoundsException,ClassCastException
  * Exception Hierarchy : Exception and Error class -> Throwable class -> Object class.
  * An object of Throwable or to it's sub classes can be "explicitly" created and thrown using "throw" keyword.
  * If a method is capable of throwing an exception(propogating an exception) that it could not handle, then it should specify that exception using "throws keyword". 
  * Unchecked exceptions propogate in calling chain automatically while Checked exceptions can't propogate automatically.
		  Super Class						Sub Class
	  1) No Exception				No Exception / Uncheked Exception
	  2) Uncheked Exception         Same / subclass of Uncheked Exception / No Exception
	  3) Checked Exception          Same / subclass of Checked Exception / No Exception
  * We can create our custom exception by extenig Exception or it's sub classes.

- Java (JVM) Memory Model – Memory Management in Java : 
 
    <-- Minor GC -->          <---- Major GC ----> 
	|              |    |    |                   |     	     	   |           |
	|     Eden     | S0 | S1 |     Old Memory    |    Perm Gen     | JVM Stack |
	|              |    |    |                   |  (Method Area)  |           |
	<--- Young Gen (-Xmn) --->    					-XX:PermGen
    <----------  Jvm Heap (-Xms -Xmx)  ---------->  -XX:MaxPermGen
  
  * At broad level, JVM Heap memory is physically divided into two parts – Young Generation and Old Generation.
  * Young Generation is divided into three parts – Eden Memory and two Survivor Memory spaces.
  * Most of the newly created objects are located in the Eden memory space.
  * When Eden space is filled with objects, Minor GC is performed and all the survivor objects are moved to one of the survivor spaces.
  * Minor GC also checks the survivor objects and move them to the other survivor space. So at a time, one of the survivor space is always empty.
  * Objects that are survived after many cycles of Minor GC, are moved to the Old generation memory space.Usually, it’s done by setting a threshold for the age 
    of the young generation objects.(Old Generation memory contains the objects that are long-lived and survived after many rounds of Minor GC)
  * Usually, garbage collection is performed in Old Generation memory (Major GC) when it’s full and usually it takes a longer time.
  * Since Young generation keeps short-lived objects, Minor GC is very fast and the application doesn’t get affected by this.
  * However, Major GC takes a long time because it checks all the live objects. Major GC should be minimized because it will make your application unresponsive 
    for the garbage collection duration
  * “Perm Gen” contains the application metadata required by the JVM to describe the classes and methods used in the application
  * Perm Gen is populated by JVM at runtime based on the classes used by the application.It also contains Java SE library classes and methods. 
  * Perm Gen objects are garbage collected in a full garbage collection.
  * Method Area is part of space in the Perm Gen and used to store class structure (runtime constants and static variables) and code for methods and constructors.
  * Memory Pools (e.g String Pool) are created by JVM memory managers to create a pool of immutable objects if the implementation supports it.It can belong to 
    Heap or Perm Gen, depending on the JVM memory manager implementation.
  * Runtime constant pool is per-class runtime representation of constant pool in a class.It contains class runtime constants and static methods. It is part of the method area.
  * Stack memory : 
    * It is used for execution purpose execution of a thread).contains only local primitive values and reference to other objects(passed as an argument). 
  * Heap memory : 
    * Heap memory is used for storage purpose.Used to allocate memory to objects and JRE classes.Garbage Collection runs on the heap memory.
    * Object created in heap memory has glaobal access.
	1) -Xms : For setting the initial heap size when JVM starts
    2) -Xmx : For setting the maximum heap size.
    3) -Xmn : For setting the size of the Young Generation, rest of the space goes for Old Generation.
    4) -XX:PermGen : For setting the initial size of the Permanent Generation memory
    5) -XX:MaxPermGen : For setting the maximum size of Perm Gen
    6) -XX:SurvivorRatio : For providing ratio of Eden space and Survivor Space.default is 8.e.g if Young Generation=10m and -XX:SurvivorRatio=2 then 5m will be reserved for Eden Space and 2.5m each for both the Survivor spaces.
    7) -XX:NewRatio : For providing ratio of old/new generation sizes. The default value is 2.
- Garbage Collection : 
  * Garbage Collection is process to destroy the unused objects("unreferenced").
  * Garbage Collection of JVM collects only those objects that are created by new keyword. 
  * If you have created any object without new, you can use finalize method to perform cleanup processing. 
  * Garbage collection is performed by a daemon thread called Garbage Collector(GC). 
  * This thread calls the finalize() method before object is garbage collected.
  * Exceptions occured in finalize() method are not propogated.They are ignore by the garbage collector.
  * Neither finalization nor garbage collection is guaranteed.  
  * basic ways of garbage collection involves three steps:
    1) Marking : identifies which objects are in use and which ones are not in use.
    2) Normal Deletion : removes the unused objects.
    3) Deletion with Compacting: after dele-ting unused objects, all the survived objects can be moved to be together.
  * Garbage Collection Types : 
    1) Serial GC (-XX:+UseSerialGC) : 
	   * It uses the simple mark-sweep-compact approach for young and old generations garbage collection.
       * It is useful in simple stand-alone applications and machines with smaller CPU.
    2) Parallel GC (-XX:+UseParallelGC): 
	   * It is same as Serial GC except that is spawns N threads for young generation garbage collection where N is the number of CPU cores in the system. 
	   * We can control the number of threads using -XX:ParallelGCThreads=n JVM option.
       * It is also called throughput collector because it uses multiple CPUs to speed up the GC performance. 
	   * It uses a single thread for Old Generation garbage collection.
    3) Parallel Old GC (-XX:+UseParallelOldGC): 
	   * It is same as Parallel GC except that it uses multiple threads for both Young Generation and Old Generation garbage collection.
Concurrent Mark Sweep (CMS) Collector (-XX:+UseConcMarkSweepGC): CMS Collector is also referred as concurrent low pause collector. It does the garbage collection for the Old generation. CMS collector tries to minimize the pauses due to garbage collection by doing most of the garbage collection work concurrently with the application threads.
CMS collector on the young generation uses the same algorithm as that of the parallel collector. This garbage collector is suitable for responsive applications where we can’t afford longer pause times. We can limit the number of threads in CMS collector using -XX:ParallelCMSThreads=n JVM option.
G1 Garbage Collector (-XX:+UseG1GC): The Garbage First or G1 garbage collector is available from Java 7 and its long term goal is to replace the CMS collector. The G1 collector is a parallel, concurrent, and incrementally compacting low-pause garbage collector.

- Enums : used for "grouping similar kind of constants" as a one unit. (Introduced in JDK 1.5 onward)
  * can have any number of fields,methods and constructors and Each constant will have their own copy.You can delcare main() method inside Enum also.
  * Enum can have concreate/abstract/static methods.
  * Every enum extends Enum class.So,it could not extend any other class.But can implement any number of interfaces.
  * Enums can be declare otside class or inside class (static implicitly) but not inside method.
  * Enum is type-safe. You can not assign any other value to Enum variable other than Predefined Enum constants.
  * First line of Enum must be constant decalration only.Every Enum constant represents an object of type Enum.
  * Every Enum constant is always public static final (can be treated as static inner classes).Since it is static,You can access it through Enum name.Since it is
    final,You can not create child Enum.
  * values() method is used to get all value present inside Enum.ordinal() method is used to find index of each Enum constant.
  * Enum can have private/default constructor and it will be executed seprately for each Enum constant at the time of Enum class loading.
  * Enum constant can be declared with parameterized values (for that you have to  define parameterized constructor).
- Serialization  : convertion of a Java object to an Stream.Once an object is converted to Stream, it can be saved to file or send over the network.
  * object should implement Serializable (I) and we can use ObjectOutputStream to write object to file or to any OutputStream object.
  * transient keyword is used in serealization.
	  * transient data member can not be serealized.
	  * For transient varaibles, JVM takes defualt value at the time of serealization. e.g we don't want to save private data in file.
	  * static fields are not part of object.so,no use of transient with it.
	  * final variables are directly serealized by their value.so no use of transient with final varaible also.
- Deserialization : process of converting stream data created through serialization to Object.

- Multi Threading : 
  * Thread is a smallest executable unit of a process.
  * Thread shares a common memory of process.Hence, Inter Thread Communication is fast. 
  * Context switching from one thread to another thread is also less expensive.
  * Every thread maintains its own separate stack (Runtime Stack). But, they share the same memory.
  * Ways to create threads : 1) By extending Thread class (by overriding run() method) 2) By implementing Runnable interface (by implementing run() method)
    * When multiple threads need to execute same task, then use Runnable interface. 
	* If multiple threads need to execute different tasks, then go for Thread class.
  * If you will start already started thread again , It will throw IllegalThreadStateException.
  * If we call run() directly before start(), than object will be treated as normal object not thread object.
  * User threads are created by application/user (High priority) while Daemon threads are created by the JVM (Low priority).JVM will not wait for Daemon thread.
  * Every java application has at least one thread – main thread.
  * You can convert user thread into daemon thread by calling "setDaemon()" method before "start()" method (else IllegalThreadStateException at run time)
  * "currentThread()" static method of Thread class returns the reference of currently executing thread.
  * From Java 1.5, "getId()" method is added into Thread class which returns the unique long number associated with a thread.(To identify each thread uniqely). 
    * Thread Id remains the same for a thread during its whole life term. It may be reused when the thread is terminated.
	* It doesn't change when the name of a thread is changed. 
	* We can't assign our own Id to the thread. But, we can change the way getId() returns the thread Id as it is not a final method.
  * setPriority() and getPriority() methods are used to get and set the priority of a thread. (MIN_PRIORITY - 1 , NORM_PRIORITY - 5 ,MAX_PRIORITY - 10)
    * Setting Priority of a thread is just an advice to OS not an instruction. It is up to OS to consider this advice.
  * Thread.sleep() static method makes the "currently executing thread" (even though you are calling sleep() method on another thread object) to pause its execution
    for a specified period of time.
	* It is a bad practice to call sleep() method with an instance of Thread class.
	* If you want a particular thread to sleep for a while, then call sleep() method inside the run() method of that thread.
	* When the thread is going for sleep, it does not release the "synchronized locks" it holds.
  * join() method is used to make currently executing thread to wait for a thread to finish its task "on which it is called".
  * Thread.sleep() / join() method throws InterruptedException (checked type) if a thread is interrupted by other threads. 
  * "Thread interference" is a condition which occurs when more than one threads, executing simultaneously, access same piece of data.(not thread safe code)
  * Synchronization : process to overcome thread interference to any shared resource and protecting the data from inconsistency.(way to make code thread safe)
    * Through synchronization, we can make the threads to execute particular method or block in "sync" not "simultaneously".
	* Synchronization is implemented using synchronized keyword.(can be used with methods or blocks only).
	* Synchronization is built around an entity called "object lock" or "monitor".
	* Whenever an object is created, an "object lock" or "monitor" is created and is stored inside the object.
	* One object will have only one object lock associated with it.
	* To enter into static synchronized methods/blocks, threads have to acquire "class lock" associated with that class.
	* If any thread wants to enter into synchronized methods/blocks of any shared object,they must acquire object lock associated with that shared object and 
      release the lock after they are done with the execution.
	* Synchronized Blocks are used to synchronized some part of method/block.It takes one argument(mutex).for non-static methods,IIB and constructors,mutex must be 
      shared object.While for static methods and SIB, mutex must be like ClassName.class.
	* static synchronized and non-static synchronized methods can run simultaneously.
	* Synchronization can be nested.It is Re-entrant in nature (in nested calling,Thread can acquire a lock that it already owns)
    * Deadlock is a condition which occurs when two or more threads get blocked waiting for each other to release the resources(Locks) they hold.
	  * Try to avoid nested synchronized blocks to overcome possible deadlock issue.
  * Threads can communicate with each other using wait(), notify() and notifyAll() final methods of Object class.
    * These three methods must be called within synchronized method or block. Any thread which calls these methods must have lock of that object.
	* wait() method tells the currently executing thread to "release the lock" of shared object and wait until some other thread acquires the same lock and 
	  notify it using either notify() or notifyAll() methods. This method throws InterruptedException if waiting thread is interrupted.
    * DIFF: In sleep() method call, thread doesn't release object lock while on wait() method call , thread release the object lock.
    * wait(), notify() and notifyAll() all three methods throw IllegalMonitorStateException if the calling thread does not owns the object lock.
	* Thread "interruption" is a mechanism in which a thread which is either sleeping or waiting can be made to stop sleeping or waiting.
  * Thread State ( Thread Lifecycle) : 
    1) NEW : When a thread is just created.
	2) RUNNABLE : When a start() method is called over thread processed by the thread scheduler.(Can be a running thread / Can not be a running thread)
	3) RUNNING : When the scheduler has selected thread to be run, the thread's state is running from runnable state.
	4) WAITING/TIMED_WAITING : A thread goes to wait state once it calls wait() on an Object.
	5) BLOCKED : When the scheduler has selected thread, not to allow a thread to change state from runnable to run it's in blocked state.
	6) TERMINATED : When the run() method exists or stop() method is called over a thread.
  * Before notification thread will be in WAITING state.Once it is notified,it moves to BLOCKED state.It remains in BLOCKED state until it gets the lock.
    Once it gets the lock,it moves from BLOCKED state to RUNNING state. 
  * ThreadGroup is used to group similar kind of threads into one unit.ThreadGroup can also contain other ThreadGroups.
  * Exception is thread wise not execution wise.exception effects only in the thread in which it occurs.Other threads will execute normally.
  * Ways to stop a thread 1) using boolean variable 2) using interrupt() method
  * volatile variable is used to Read/Write variable value directly from main memory only.(Instead of caching it).
	* It also guarantees visibility and ordering.(provides "happens-beofore" guaranty)
	* Atomic operations are take place in one step.
	* Reading/Writing 64 bit long or double is not atomic(as it occurs in two steps).Hence, it is not thread safe.To ensure atomic/thread safety, it is essential
	  to use volatile (or synchronized block) 
  * Atomic operations are performed in a single unit of task without interference from other operations. Atomic operations are necessity in multi-threaded environment to avoid data inconsistency.
  * java.util.concurrent.atomic provides wrapper classes for int and long that can be used to achieve this atomic operation without usage of Synchronization.
  * AtomicInteger method incrementAndGet() atomically increments the current value by one.
  * Atomic operation concurrency classes are assumed to be more efficient that synchronization which involves locking resources.
	  
- The shutdown hook can be used to perform cleanup resource or save the state when JVM shuts down normally or abruptly.
- Java Runtime class is used to interact with java runtime environment.
  * It provides methods to execute a process, invoke GC, get total and free memory etc.
  * There is only one instance of Runtime class is available for one java application.
  
- Reflection API provides the ability to inspect and modify the runtime behavior of java application. 
  * We can inspect a java class, interface, enum and get their methods and field details. 
  * Reflection API usage can break the design pattern such as Singleton pattern by invoking the private constructor i.e violating the rules of access modifiers.
- For financial calculations,One should use "BigDecimal" (as floating point calculation may not be exact).Here, if you use BigDecimal constuctor which accept
  double as argument,you will get the incorrect result.So alway use BigDecimal with string constuctor.  	   
- Nested class 1) Static nested class 2) Non-static nested class/Inner class(Member inner class,Local inner class,Anonymous inner class).  
  * Static nested class : can have "static" and "non-static" members. but can access only "static members" of "outer class".
	* Static method can't be abstract but static nested class can be abstract or final.
	* Instantiation : OuterClass.StaticInnerClass obj = new OuterClass.StaticInnerClass();
  * Non-Static nested classe : can have only "non-static" members but can access both "static" and "non-static" members of "outer class".
    * Member inner class (outside method) and Local inner class(inside method or block) can have static field only if that field is final.
	* Instantiation : OuterClass.MemberInnerClass obj =  outerClassObj.new MemberInnerClass();
	* Local Inner Class can’t be static.Because, local inner class is nothing but local variable and local variable can’t be static.
	* Only final local variables of methods or blocks cab be used inside local inner class.But after JDK 1.8, it is possible to access it (effective final).
	* Since an anonymous class has no name, it is not possible to define a constructor for an anonymous class.They are accessible only at the point where it is 
	  defined.
- Nested interface(static implicitely) must be public if it is declared inside the interface but it can have any access modifier if declared within the class.
----- Java8 -----
4) JAVA 1.8 : 
4.1) forEach() method in Iterable interface : 
     * takes Consumer object as argument, so it helps in having our business logic at a separate location that we can reuse. 
	 * It helps in having the logic for iteration and business logic at separate place resulting in higher separation of concern and cleaner code.
       myList.forEach( (k) -> {System.out.println("Value :" + k);} ); or 
	   myList.forEach(new Consumer<Integer>() { // anonymous impl
			public void accept(Integer t) {
				System.out.println("Value :" + t);
			}
	   });
  
4.2) default and static methods in Interfaces :
     * help us to introduce new functionality without breaking the existing code.
	 * Multiple inheritance problem can occur, when we have two interfaces with the default methods of same signature.In this case implementation class must have
   	   to overide default method so as to avoid ambiguity.In this case You can also resuse existing implementation of any of interface class default method. e.g 
	   interface InterfaceA {
			default void method1(){ // some code };
	   }
	   interface InterfaceB {
			default void method1(){ // some code };
	   }
	   class classA implements InterfaceA,InterfaceB{
			@Override
			public void method1(){ 
				new InterfaceA.super.method1();
			}
	   }
	 * If any class in the hierarchy has a method with same signature, then default methods become irrelevant. 
	 * Since any class implementing an interface already has Object as superclass,if we have equals(), hashCode() default methods in interface, it will become 
	   irrelevant. Thats why for better clarity, interfaces are not allowed to have Object class default methods.
	 * Though from java8 , inteface have default method still it is not same as Abstract class. As abstract class can have constructor while in interfaces we can’t have constructors.
	 * interface static methods are used to define interface-related utils or factory methods.
4.3) Functional Interfaces and Lambda Expressions : 
     * Java has always been an Object Oriented Programming language. We don’t have only functions (methods) in java, they are part of Class and we need to use 
	   the class/object to invoke any function (method).
     * it brings a lot of verbosity to the program. e.g 
		  Runnable r = new Runnable(){
			@Override
			public void run() { System.out.println("My Runnable");}
		  };
	 * Java 8 Functional Interfaces and Lambda Expressions help us in writing smaller and cleaner code by removing a lot of boiler-plate code.
	 * Through Lambda Expression we can visualize functional programming in the java object oriented world and can pass behaviour into method.
     * interface with exactly one "abstract method" becomes Functional Interface.
	 * @FunctionalInterface annotation is optional.However, it avoids accidental addition of another abstract method.
	 * Through lamda expression we can create anonymous classes of functional interfaces.
       Runnable r1 = () -> { System.out.println("My Runnable"); };
	 * Consumer :  void accept(T t);
	 * Supplier :  T get();
	 * Function :  R apply(T t);
	 * Predicate : boolean test(T t);
	 * If functional interface have one non-Object abstract method with other Object class public method as an abstract method, it will be still trited as a 
	   functional interface.
	 * If interface A will extends two functional interface B and C which have same signature, than A will be still trited as a functional interface.Here it will
   	   check subsignature & return-type-substitutable
	   
4.4) Java Stream API : 
     * to perform filter/map/reduce like operations with the collection. Stream API will allow sequential as well as parallel execution.
	 * Collection interface has been extended with stream() and parallelStream() default methods to get the Stream for sequential and parallel execution. e.g 
		  List<Integer> myList = Arrays.asList(1,2,3,4,5);
		  Stream<Integer> sequentialStream = myList.stream();  //sequential stream
		  Stream<Integer> parallelStream = myList.parallelStream();  //parallel stream
		  Stream<Integer> highNums = parallelStream.filter(p -> p > 3);
		  highNums.forEach(p -> System.out.println("High Nums parallel="+p));		
		  Stream<Integer> highNumsSeq = sequentialStream.filter(p -> p > 3);
		  highNumsSeq.forEach(p -> System.out.println("High Nums sequential="+p));

5) JAVA 1.9 :
5.1) REPL (Read Evaluate Print Loop) (JShell) : 
- It is an interactive tool(Comand line interface) to execute and evaluate java simple programs like variable declarations, statements, expressions, simple 
  Programs etc. jshell don’t need any IDEs or extra editors to execute simple java programs.
- We can access Java REPL by using jshell command.

5.2) Factory Methods for Immutable List, Set, Map and Map.Entry : 
- In earlier version, we can use Collections.unmodifiableXXX() methods to create Immutable Collection objects.However these methods are very tedious and verbose 
  approach.
- To Overcome this, In Java 1.9 some convenient factory methods are introduced to create "Immutable" List, Set, Map and Map.Entry objects.e.g 
  List lst = List.of(); , Set set = Set.of("one","two","three"); , Map.of(1, "one", 2, "two", 3, "three"); , Map.Entry<Integer,String> mapEntry = Map.entry(1,"one")
  Map<Integer,String> map = Map.ofEntries(entry(1,"one"),entry(2,"two"), entry(3,"three")) 

5.3) Private methods in Interface : 
- To avoid redundant code and to provide more re-usability,Java 1.9 has intoduced private/private static methods in Interfaces. 

5.4) Try With Resources Improvement : 
- It has provided some imporovement to reduce verbosity and to imrove redability. e.g 
  In 1.7 :  BufferedReader reader1 = new BufferedReader(new FileReader("abc.txt"));
           try (BufferedReader reader2 = reader1) {
				System.out.println(reader2.readLine());
		   }
  In 1.9 :  BufferedReader reader1 = new BufferedReader(new FileReader("abc.txt"));
           try (reader1) {
				System.out.println(reader1.readLine());
		   }

5.6) Diamond Operator for Anonymous Inner Class : 
 
5.7) Java 9 Module System (Jigsaw project) : 

6) JAVA 1.10 :
6.1) Local-Variable Type Inference : 
- It adds type inference to declarations of local variables with initializers. Local type inference can be used only in the following scenarios:
  Lmited only to Local Variable with initializer , Indexes of enhanced for loop or indexes , Local declared in for loop e.g 
  var numbers = List.of(1, 2, 3, 4, 5); // inferred value ArrayList<String>
  
7) Java 11 : 
- Made Licence version for commercial use.
- We can run a java program directly through java command.(source file will be implicitly compiled)
- 6 new methods added in String class – isBlank(), lines(), strip(), stripLeading(), stripTrailing(), and repeat().
- Files class got two new methods to read/write string data – readString() and writeString().
- We can use “var” with lambda expressions too.  	

8) Java 12 : March 2019
   1) Switch Expressions : 
      * new Syntax removes the need for break statement to prevent fallthroughs. Switch Expressions don’t fall through anymore.
	  * we can define multiple constants in the same label.
      * default case is now compulsory in Switch Expressions.
      * break is used in Switch Expressions to return values from a case itself. e.g 
        String result = switch (day) {
				case "M", "W", "F" -> "MWF";
				case "T", "TH", "S" -> "TTS";
				default -> {
					if(day.isEmpty())
						break "Please insert a valid day.";
					else
						break "Looks like a Sunday.";
				}
			};	  
    2) File.mismatch method : 
	3) Java Strings New Methods : indent(int n) , transform(Function<? super String,?? extends R> f) , Optional<String> describeConstable()
	
	
1) Java 1.5 :
- Generics , Enhanced for Loop (for-each loop), Autoboxing/Unboxing , Typesafe Enums (Enums) , Varargs , Static Import , Executors framework 

2) Java 1.6 :
- JDBC 4.0

3) Java 1.7
  1) Strings in switch Statement 
  2) Multiple Exception Handling (Using | operator in catch block) 
  3) Try with Resources (for Automatic resource management in try-statement (AutoCloseable interface)
  4) Diamond operator : Type Inference for Generic Instance Creation  (e.g ArrayList<String> lst = new ArrayList<>(); ) (It will reduce verbosity)
  5) Automatic null Handling (Null-safe operator) : e.g String postalCode = person?.getAddress()?.getPostcode(); (To avoid lots of if checks)
----------------------------------------
- Object-Oriented Design Principles (SOLID) : 
1) Single responsibility principle :
   * Class should only have one resaon to change.class should always handle single functionality.
   * more than one functionality in one Class,introduces coupling between two functionality, and even if you change one feature, there is a chance you broke 
     coupled functionality,  which requires another round of testing
2) Open-closed principle : 
   * class should be open for extension but closed for modification.
   * new functionality should be added by introducing new classes, methods or fields instead of modifying already tried and tested code
   * One of the way to achieve this is Inheritance where class is extended to introduce new functionality on top of inherited basic features.
   * By providing object to class at run time and making use of polymorphism to invoke extended functionality,we can make code extensible.
3) Liskov substitution principle : 
   * Subtypes must be substitutable for supertype.
   * methods which use superclass type must be able to work with the object of subclass without any issue.
   * In order to follow LSP , subclass must enhance functionality, but not reduce them.
4) Interface segregation principle : 
   * client should not implement an interface if it doesn't use that.Avoid monolithic interface,reduce pain in client side.
   * This happens mostly when one interface contains more than one functionality, and the client only needs one functionality and no other.
5) Dependency Injection/Inversion principle : 
   * Don't ask for dependency; it will be provided to you by the framework.
   * any class which is injected by DI framework is easy to test with the mock object and more comfortable to maintain because object creation code is centralized in the framework

6) DRY (Don't repeat yourself) : 
   * don't write duplicate code for related functionalities,instead use Abstraction to abstract common things in one place.
   * It Provides benefit during maintenance of code and avoids duplication in code.
7) Encapsulate What Changes : 
   * encapsulate the code you expect to be changed in the future.
   * make variable and methods private by default and increasing access step by step, e.g. from private to protected and not public.
   * hides implementation details, helps in maintenance
8) Favor Composition over Inheritance : 
   * Composition allows changing the behavior of a class at run-time by setting property during run-time.
9) Programming for Interface not implementation : 
   * Helps in maintenance, improves flexibility
   * It will provide flexible code that can work with any new implementation of the interface.
   * use interface type on variables, return types of method or argument type of methods.
10) Delegation principles : 
    * Don't do all stuff by yourself,  delegate it to the respective class.
	* e.g  equals() and hashCode() method : In order to compare two objects for equality, we ask the class itself to make comparison instead of the Client class
  	  doing that check.
------------------------------------------------------------
- Difference between test driven development (TDD) , behaviour driven development (BDD) and Domain Driven Design (DDD) ?
  * TDD : first come tests and then the code. The minimal piece of code is written in order to pass the designed  test. In other words, it is the process of 
    testing the code before its accrual writing. If the code passes the test, then we can proceed to its refactoring.
  * DDD : is the way of creating complex systems by developing the separate parts of it. At first, the domain (a set of functionality) is defined and described 
    as before creating something it is necessary to understand what exactly it will be. In other words, it is the process of being informed about the domain 
	before code writing.
  * BDD : is a customer-focused process. It is based on the full and clear understanding of the system or module behavior but in the terms of business/client. 
    We can say that BDD is the implemented TDD with some aspects of DDD.
  * The tests for TDD are created by developers for developers. The test for BDD can be written by testers or technical managers.
  * DDD is focused on researching, defining all required aspects before proceeding to coding. TDD is the procedure of accrual code writing.	    
----- JDBC -----
- Third higest and Third lowest salary
  SELECT MIN(SALARY) FROM (SELECT DISTINCT SALRY FROM EMPLOYEE ORDER BY SALARY DESC FETCH FIRST 3 ROWS ONLY) ; -- MAX : DB2
  SELECT MAX(SALARY) FROM (SELECT DISTINCT SALRY FROM EMPLOYEE ORDER BY SALARY) WHERE ROWNUM <= 3 ; -- MAX : ORACLE
- SQL qery to display current date : 
  SELECT SYSDATE FROM DUAL ;  OR  SELECT TO_CHAR(SYSDATE,'DD-MM-YYYY HH:MM:SS AM') FROM DUAL ; 
- SQL query to check whether date passed to query is of given format or not :   
  SELECT * FROM EMPLOYEE WHERE TRUNC(BIRTH_DATE) = TO_DATE('17-05-2019', 'DD-MM-YYYY') ;
- How to find duplcate rows in database :  
  SELECT EMP_ID,EMP_NAME,COUNT(*) FROM EMPLOYEE GROUP BY EMP_ID,EMP_NAME HAVING COUNT(*) > 1 ;
- How to remove duplcate rows in database :   
  DELETE FROM EMPLOYEE WHERE ROWID NOT IN (SELECT MIN(ROWID) FROM EMPLOYEE GROUP_BY EMP_ID,EMP_NAME) ; -- ORACLE
  DELETE FROM (SELECT ROWNUMBER() OVER(PARTITION BY EMP_ID,EMP_NAME) AS PART_WISE_ROW_ID FROM EMPLOYEE) WHERE PART_WISE_ROW_ID > 1 ; -- DB2
------------------------------------------------------------------------------------
https://javarevisited.blogspot.com/2018/07/10-object-oriented-design-principles.html
